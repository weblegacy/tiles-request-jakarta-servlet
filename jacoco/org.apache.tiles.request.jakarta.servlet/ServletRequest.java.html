<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ServletRequest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Tiles request - Jakarta-Servlet support</a> &gt; <a href="index.source.html" class="el_package">org.apache.tiles.request.jakarta.servlet</a> &gt; <span class="el_source">ServletRequest.java</span></div><h1>ServletRequest.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2023 Web-Legacy
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.tiles.request.jakarta.servlet;

import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import org.apache.tiles.request.AbstractClientRequest;
import org.apache.tiles.request.ApplicationContext;
import org.apache.tiles.request.attribute.Addable;
import org.apache.tiles.request.collection.HeaderValuesMap;
import org.apache.tiles.request.collection.ReadOnlyEnumerationMap;
import org.apache.tiles.request.collection.ScopeMap;
import org.apache.tiles.request.jakarta.servlet.extractor.HeaderExtractor;
import org.apache.tiles.request.jakarta.servlet.extractor.ParameterExtractor;
import org.apache.tiles.request.jakarta.servlet.extractor.RequestScopeExtractor;
import org.apache.tiles.request.jakarta.servlet.extractor.SessionScopeExtractor;

import jakarta.servlet.RequestDispatcher;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Servlet-based implementation of the TilesApplicationContext interface.
 *
 * &lt;p&gt;Copied from Apache tiles-request-servlet 1.0.7 and adapted for
 * Jakarta EE 9.&lt;/p&gt;
 */
public class ServletRequest extends AbstractClientRequest {

    /**
     * The native available scopes: request, session and application.
     */
<span class="fc" id="L56">    private static final List&lt;String&gt; SCOPES</span>
<span class="fc" id="L57">            = Collections.unmodifiableList(Arrays.asList(</span>
                    REQUEST_SCOPE, &quot;session&quot;, APPLICATION_SCOPE));

    /**
     * The request object to use.
     */
    private HttpServletRequest request;

    /**
     * The response object to use.
     */
    private HttpServletResponse response;

    /**
     * The response output stream, lazily initialized.
     */
    private OutputStream outputStream;

    /**
     * The response writer, lazily initialized.
     */
    private PrintWriter writer;

    /**
     * The lazily instantiated {@code Map} of header name-value combinations
     * (immutable).
     */
<span class="fc" id="L84">    private Map&lt;String, String&gt; header = null;</span>

    /**
     * The lazily instantiated {@code Map} of header name-value combinations
     * (write-only).
     */
<span class="fc" id="L90">    private Addable&lt;String&gt; responseHeaders = null;</span>

    /**
     * The lazily instantiated {@code Map} of header name-values combinations
     * (immutable).
     */
<span class="fc" id="L96">    private Map&lt;String, String[]&gt; headerValues = null;</span>

    /**
     * The lazily instantiated {@code Map} of request parameter name-value.
     */
<span class="fc" id="L101">    private Map&lt;String, String&gt; param = null;</span>

    /**
     * The lazily instantiated {@code Map} of request scope attributes.
     */
<span class="fc" id="L106">    private Map&lt;String, Object&gt; requestScope = null;</span>

    /**
     * The lazily instantiated {@code Map} of session scope attributes.
     */
<span class="fc" id="L111">    private Map&lt;String, Object&gt; sessionScope = null;</span>

    /**
     * Creates a new instance of ServletTilesRequestContext.
     *
     * @param applicationContext The application context.
     * @param request            The request object.
     * @param response           The response object.
     */
    public ServletRequest(
            ApplicationContext applicationContext,
            HttpServletRequest request, HttpServletResponse response) {

<span class="fc" id="L124">        super(applicationContext);</span>
<span class="fc" id="L125">        this.request = request;</span>
<span class="fc" id="L126">        this.response = response;</span>
<span class="fc" id="L127">    }</span>

    /**
     * Return an immutable Map that maps header names to the first (or only)
     * header value (as a String).
     *
     * @return The header map.
     */
    @Override
    public Map&lt;String, String&gt; getHeader() {
<span class="pc bpc" id="L137" title="2 of 4 branches missed.">        if (header == null &amp;&amp; request != null) {</span>
<span class="fc" id="L138">            header = new ReadOnlyEnumerationMap&lt;String&gt;(</span>
                    new HeaderExtractor(request, null));
        }

<span class="fc" id="L142">        return header;</span>
    }

    /**
     * Return an add-able object that can be used to write headers to the
     * response.
     *
     * @return An add-able object.
     */
    @Override
    public Addable&lt;String&gt; getResponseHeaders() {
<span class="pc bpc" id="L153" title="2 of 4 branches missed.">        if (responseHeaders == null &amp;&amp; response != null) {</span>
<span class="fc" id="L154">            responseHeaders = new HeaderExtractor(null, response);</span>
        }

<span class="fc" id="L157">        return responseHeaders;</span>
    }

    /**
     * Return an immutable Map that maps header names to the set of all values
     * specified in the request (as a String array). Header names must be
     * matched in a case-insensitive manner.
     *
     * @return The header values map.
     */
    @Override
    public Map&lt;String, String[]&gt; getHeaderValues() {
<span class="pc bpc" id="L169" title="2 of 4 branches missed.">        if (headerValues == null &amp;&amp; request != null) {</span>
<span class="fc" id="L170">            headerValues = new HeaderValuesMap(</span>
                    new HeaderExtractor(request, response));
        }

<span class="fc" id="L174">        return headerValues;</span>
    }

    /**
     * Return an immutable Map that maps request parameter names to the first
     * (or only) value (as a String).
     *
     * @return The parameter map.
     */
    @Override
    public Map&lt;String, String&gt; getParam() {
<span class="pc bpc" id="L185" title="2 of 4 branches missed.">        if (param == null &amp;&amp; request != null) {</span>
<span class="fc" id="L186">            param = new ReadOnlyEnumerationMap&lt;String&gt;(</span>
                    new ParameterExtractor(request));
        }

<span class="fc" id="L190">        return param;</span>
    }

    /**
     * Return an immutable Map that maps request parameter names to the set of
     * all values (as a String array).
     *
     * @return The parameter values map.
     */
    @Override
    public Map&lt;String, String[]&gt; getParamValues() {
<span class="fc" id="L201">        return request.getParameterMap();</span>
    }

    /**
     * Returns a context map, given the scope name.
     *
     * &lt;p&gt;This method always return a map for all the scope names returned by
     * {@link #getAvailableScopes()}. That map may be writable, or immutable,
     * depending on the implementation.
     *
     * @param scope The name of the scope.
     *
     * @return The context.
     */
    @Override
    public Map&lt;String, Object&gt; getContext(String scope) {
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (REQUEST_SCOPE.equals(scope)) {</span>
<span class="nc" id="L218">            return getRequestScope();</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">        } else if (&quot;session&quot;.equals(scope)) {</span>
<span class="nc" id="L220">            return getSessionScope();</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        } else if (APPLICATION_SCOPE.equals(scope)) {</span>
<span class="nc" id="L222">            return getApplicationScope();</span>
        }

<span class="nc" id="L225">        throw new IllegalArgumentException(scope + &quot; does not exist. &quot;</span>
                + &quot;Call getAvailableScopes() first to check.&quot;);
    }

    /**
     * Returns the context map from request scope.
     *
     * @return the context map from request scope
     */
    public Map&lt;String, Object&gt; getRequestScope() {
<span class="pc bpc" id="L235" title="2 of 4 branches missed.">        if (requestScope == null &amp;&amp; request != null) {</span>
<span class="fc" id="L236">            requestScope = new ScopeMap(new RequestScopeExtractor(request));</span>
        }

<span class="fc" id="L239">        return requestScope;</span>
    }

    /**
     * Returns the context map from session scope.
     *
     * @return the context map from session scope
     */
    public Map&lt;String, Object&gt; getSessionScope() {
<span class="pc bpc" id="L248" title="2 of 4 branches missed.">        if (sessionScope == null &amp;&amp; request != null) {</span>
<span class="fc" id="L249">            sessionScope = new ScopeMap(new SessionScopeExtractor(request));</span>
        }

<span class="fc" id="L252">        return sessionScope;</span>
    }

    /**
     * Returns all available scopes.
     *
     * &lt;p&gt;The scopes are ordered according to their lifetime, the innermost,
     * shorter lived scope appears first, and the outermost, longer lived scope
     * appears last. Besides, the scopes &quot;request&quot; and &quot;application&quot; always
     * included in the list.&lt;/p&gt;
     *
     * @return All the available scopes.
     */
    @Override
    public List&lt;String&gt; getAvailableScopes() {
<span class="nc" id="L267">        return SCOPES;</span>
    }

    /**
     * Forwards to a path.
     *
     * @param path The path to forward to.
     *
     * @throws IOException If something goes wrong when forwarding.
     */
    @Override
    public void doForward(String path) throws IOException {
<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (response.isCommitted()) {</span>
<span class="fc" id="L280">            doInclude(path);</span>
        } else {
<span class="fc" id="L282">            forward(path);</span>
        }
<span class="fc" id="L284">    }</span>

    /**
    * Includes the content of a resource (servlet, JSP page, HTML file) in the
    * response. In essence, this method enables programmatic server-side includes.
    *
    * @param path a {@code String} specifying the pathname to the resource. If
    *        it is relative, it must be relative against the current servlet.
    *
    * @throws IOException if the included resource throws this exception
    *
    * @see RequestDispatcher#include(jakarta.servlet.ServletRequest, ServletResponse)
    */
    public void doInclude(String path) throws IOException {
<span class="fc" id="L298">        RequestDispatcher rd = request.getRequestDispatcher(path);</span>

<span class="fc bfc" id="L300" title="All 2 branches covered.">        if (rd == null) {</span>
<span class="fc" id="L301">            throw new IOException(&quot;No request dispatcher returned for path '&quot;</span>
                    + path + &quot;'&quot;);
        }

        try {
<span class="fc" id="L306">            rd.include(request, response);</span>
<span class="fc" id="L307">        } catch (ServletException ex) {</span>
<span class="fc" id="L308">            throw ServletUtil.wrapServletException(</span>
                    ex, &quot;ServletException including path '&quot; + path + &quot;'.&quot;);
<span class="fc" id="L310">        }</span>
<span class="fc" id="L311">    }</span>

    /**
     * Forwards to a path.
     *
     * @param path The path to forward to.
     *
     * @throws IOException If something goes wrong during the operation.
     */
    private void forward(String path) throws IOException {
<span class="fc" id="L321">        RequestDispatcher rd = request.getRequestDispatcher(path);</span>

<span class="fc bfc" id="L323" title="All 2 branches covered.">        if (rd == null) {</span>
<span class="fc" id="L324">            throw new IOException(&quot;No request dispatcher returned for path '&quot;</span>
                    + path + &quot;'&quot;);
        }

        try {
<span class="fc" id="L329">            rd.forward(request, response);</span>
<span class="fc" id="L330">        } catch (ServletException ex) {</span>
<span class="fc" id="L331">            throw ServletUtil.wrapServletException(</span>
                    ex, &quot;ServletException including path '&quot; + path + &quot;'.&quot;);
<span class="fc" id="L333">        }</span>
<span class="fc" id="L334">    }</span>

    /**
     * Returns a {@link jakarta.servlet.ServletOutputStream} suitable for
     * writing binary data in the response. The servlet container does not
     * encode the binary data.
     *
     * @return a {@link jakarta.servlet.ServletOutputStream} for writing binary
     *         data
     *
     * @throws IllegalStateException if the {@code getWriter} method has
     *                               been called on this response
     * @throws IOException           if an input or output exception occurred
     *
     * @see HttpServletResponse#getOutputStream()
     */
    public OutputStream getOutputStream() throws IOException {
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        if (outputStream == null) {</span>
<span class="fc" id="L352">            outputStream = response.getOutputStream();</span>
        }

<span class="fc" id="L355">        return outputStream;</span>
    }

    /**
     * Returns a {@code Writer} object that can send character text to the
     * client. The {@code Writer} uses the character encoding returned by
     * {@link HttpServletResponse#getCharacterEncoding()}. If the response's
     * character encoding has not been specified as described in
     * {@code getCharacterEncoding} (i.e., the method just returns the default
     * value {@code ISO-8859-1}), {@code getWriter} updates it to
     * {@code ISO-8859-1}.
     *
     * @return a {@code Writer} object that can return character data to the
     *         client
     *
     * @throws java.io.UnsupportedEncodingException if the character encoding
     *                               returned by {@code getCharacterEncoding}
     *                               cannot be used
     * @throws IllegalStateException if the {@code getOutputStream} method has
     *                               already been called for this response
     *                               object
     * @throws IOException           if an input or output exception occurred
     *
     * @see #getPrintWriter()
     * @see HttpServletResponse#getWriter()
     */
    public Writer getWriter() throws IOException {
<span class="fc" id="L382">        return getPrintWriter();</span>
    }

    /**
     * Returns a {@code PrintWriter} object that can send character text to the
     * client. The {@code PrintWriter} uses the character encoding returned by
     * {@link HttpServletResponse#getCharacterEncoding()}. If the response's
     * character encoding has not been specified as described in
     * {@code getCharacterEncoding} (i.e., the method just returns the default
     * value {@code ISO-8859-1}), {@code getWriter} updates it to
     * {@code ISO-8859-1}.
     *
     * @return a {@code PrintWriter} object that can return character data to
     *         the client
     *
     * @throws java.io.UnsupportedEncodingException if the character encoding
     *                               returned by {@code getCharacterEncoding}
     *                               cannot be used
     * @throws IllegalStateException if the {@code getOutputStream} method has
     *                               already been called for this response
     *                               object
     * @throws IOException           if an input or output exception occurred
     *
     * @see HttpServletResponse#getWriter()
     */
    public PrintWriter getPrintWriter() throws IOException {
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">        if (writer == null) {</span>
<span class="fc" id="L409">            writer = response.getWriter();</span>
        }

<span class="fc" id="L412">        return writer;</span>
    }

    /**
     * Returns a boolean indicating if the response has been committed. A
     * committed response has already had its status code and headers written.
     *
     * @return a boolean indicating if the response has been committed
     *
     * @see HttpServletResponse#isCommitted()
     */
    public boolean isResponseCommitted() {
<span class="fc" id="L424">        return response.isCommitted();</span>
    }

    /**
     * Sets the content type of the response being sent to the client, if the
     * response has not been committed yet. The given content type may include
     * a character encoding specification, for example,
     * {@code&gt;text/html;charset=UTF-8}. The response's character encoding is
     * only set from the given content type if this method is called before
     * {@code getWriter} is called.
     *
     * @param contentType a {@code String} specifying the MIME type of the
     *                    content
     *
     * @see HttpServletResponse#setContentType(String)
     */
    public void setContentType(String contentType) {
<span class="fc" id="L441">        response.setContentType(contentType);</span>
<span class="fc" id="L442">    }</span>

    /**
     * Returns the preferred {@code Locale} that the client will accept content
     * in, based on the Accept-Language header. If the client request doesn't
     * provide an Accept-Language header, this method returns the default
     * locale for the server.
     *
     * @return the preferred {@code Locale} for the client
     *
     * @see HttpServletRequest#getLocale()
     */
    public Locale getRequestLocale() {
<span class="fc" id="L455">        return request.getLocale();</span>
    }

    /**
     * Returns the request object to use.
     *
     * @return the request object to use
     */
    public HttpServletRequest getRequest() {
<span class="fc" id="L464">        return request;</span>
    }

    /**
     * Returns the response object to use.
     *
     * @return the response object to use
     */
    public HttpServletResponse getResponse() {
<span class="fc" id="L473">        return response;</span>
    }

    /**
     * Returns a boolean indicating whether the authenticated user is included
     * in the specified logical &quot;role&quot;. Roles and role membership can be
     * defined using deployment descriptors. If the user has not been
     * authenticated, the method returns {@code false}.
     *
     * @param role a {@code String} specifying the name of the role
     *
     * @return a {@code boolean} indicating whether the user making this
     *         request belongs to a given role; {@code false} if the user has
     *         not been authenticated
     *
     * @see HttpServletRequest#isUserInRole(String)
     */
    public boolean isUserInRole(String role) {
<span class="fc" id="L491">        return request.isUserInRole(role);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>